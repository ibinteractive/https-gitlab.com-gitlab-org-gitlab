# frozen_string_literal: true

module Gitlab
  module BackgroundMigration
    # This class populates the `vulnerability_remediations` records
    # for existing finding records.
    class PopulateVulnerabilityRemediations
      class ProjectSetting < ActiveRecord::Base # rubocop:disable Style/Documentation
        include EachBatch

        self.table_name = 'project_settings'

        scope :has_vulnerabilities, -> { where('has_vulnerabilities IS TRUE') }
      end

      class Project < ActiveRecord::Base # rubocop:disable Style/Documentation
        self.table_name = 'projects'

        has_one :project_setting, class_name: 'Gitlab::BackgroundMigration::PopulateVulnerabilityRemediations::ProjectSetting'
        has_many :vulnerability_findings, class_name: 'Gitlab::BackgroundMigration::PopulateVulnerabilityRemediations::Finding'

        scope :in_range, -> (start, stop) { joins(:project_setting).merge(ProjectSetting.has_vulnerabilities).where('id BETWEEN ? AND ?', start, stop) }

        def create_remediations
          vulnerability_findings.each_batch do |findings|
            persisted_remediations = persist_remediations_for(findings).group_by(&:checksum).transform_values(&:first)

            findings.map { |finding| finding.associate_with(persisted_remediations) }.flatten
                  .then { |upsert_data| FindingRemediation.upsert_all(upsert_data) }
          end
        end

        private

        def persist_remediations_for(findings)
          findings.map(&:raw_remediations)
                  .flatten
                  .uniq
                  .map { |r| r.persist_for(id) }
                  .compact
                  .select(&:persisted?)
        end
      end

      class Finding < ActiveRecord::Base # rubocop:disable Style/Documentation
        include ::Gitlab::Utils::StrongMemoize
        include EachBatch

        self.table_name = 'vulnerability_occurrences'

        def associate_with(remediations)
          raw_remediations.map(&:checksum)
                          .map { |checksum| remediations[checksum] }
                          .compact
                          .map { |remediation| build_upsert_data_for(remediation) }
        end

        def raw_remediations
          strong_memoize(:raw_remediations) do
            metadata.dig('remediations').to_a.flatten.compact.map { |data| RawRemediation.new(*data.values_at('summary', 'diff')) }
          end
        end

        private

        def metadata
          data = Gitlab::Json.parse(raw_metadata.to_s)

          data.is_a?(Hash) ? data : {}
        rescue JSON::ParserError
          {}
        end

        def build_upsert_data_for(remediation)
          {
            vulnerability_occurrence_id: id,
            vulnerability_remediation_id: remediation.id,
            created_at: Time.current,
            updated_at: Time.current
          }
        end
      end

      class FindingRemediation < ActiveRecord::Base # rubocop:disable Style/Documentation
        UNIQUE_INDEX = :index_vulnerability_findings_remediations_on_unique_keys

        self.table_name = 'vulnerability_findings_remediations'

        belongs_to :finding,
                   class_name: 'Gitlab::BackgroundMigration::PopulateVulnerabilityRemediations::Finding',
                   inverse_of: :finding_remediations,
                   foreign_key: 'vulnerability_occurrence_id',
                   optional: false

        belongs_to :remediation,
                   class_name: 'Gitlab::BackgroundMigration::PopulateVulnerabilityRemediations::Remediation',
                   inverse_of: :finding_remediations,
                   foreign_key: 'vulnerability_remediation_id',
                   optional: false

        def self.upsert_all(upsert_data)
          return unless upsert_data.present?

          super(upsert_data, unique_by: UNIQUE_INDEX)
        end
      end

      class Remediation < ActiveRecord::Base # rubocop:disable Style/Documentation
        include FileStoreMounter
        include ShaAttribute

        self.table_name = 'vulnerability_remediations'

        sha_attribute :checksum

        has_many :finding_remediations,
                 class_name: 'Gitlab::BackgroundMigration::PopulateVulnerabilityRemediations::FindingRemediation',
                 inverse_of: :remediation,
                 foreign_key: 'vulnerability_remediation_id'

        has_many :findings, through: :finding_remediations

        mount_file_store_uploader AttachmentUploader

        def self.safe_find_or_create_by(*args, &block)
          find_or_create_by(*args, &block)
        rescue ActiveRecord::RecordNotUnique
          find_or_create_by(*args, &block)
        end

        def self.underscore
          'vulnerabilities/remediation'
        end
      end

      class RawRemediation # rubocop:disable Style/Documentation
        def initialize(summary, diff)
          @summary = summary
          @diff = diff
        end

        def persist_for(project_id)
          Remediation.find_or_create_by(project_id: project_id, checksum: checksum) { |remediation| remediation.assign_attributes(to_hash) }
                     .tap { |remediation| log_warning(project_id, remediation.errors.full_messages.join(', ')) unless remediation.persisted? }
        rescue StandardError => error
          log_warning(project_id, error.message)
          nil
        end

        delegate :checksum, to: :diff_file
        delegate :hash, :==, to: :checksum

        private

        attr_reader :summary, :diff

        def to_hash
          {
            summary: summary.truncate(200),
            checksum: checksum,
            file: diff_file
          }
        end

        def diff_file
          @diff_file ||= DiffFile.new(diff)
        end

        def log_warning(project_id, message)
          ::Gitlab::BackgroundMigration::Logger.warn(
            migrator: 'Gitlab::BackgroundMigration::PopulateVulnerabilityRemediations',
            message: message,
            project_id: project_id
          )
        end

        class DiffFile < StringIO # rubocop:disable Style/Documentation
          # This method is used by the `carrierwave` gem
          def original_filename
            "#{checksum}.diff"
          end

          def checksum
            @checksum ||= Digest::SHA256.hexdigest(string)
          end
        end
      end

      def perform(*range)
        projects = Project.in_range(*range)

        projects.each do |project|
          project.create_remediations
        end
      ensure
        log_info(projects.count)
      end

      def log_info(projects_count)
        ::Gitlab::BackgroundMigration::Logger.info(
          migrator: self.class.name,
          message: 'Remediations has been created for projects',
          count: projects_count
        )
      end
    end
  end
end
