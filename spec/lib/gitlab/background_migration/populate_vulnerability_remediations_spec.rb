# frozen_string_literal: true

require 'spec_helper'

RSpec.describe Gitlab::BackgroundMigration::PopulateVulnerabilityRemediations, schema: 20201209095814 do
  let(:namespaces) { table(:namespaces) }
  let(:projects) { table(:projects) }
  let(:project_settings) { table(:project_settings) }
  let(:scanners) { table(:vulnerability_scanners) }
  let(:identifiers) { table(:vulnerability_identifiers) }
  let(:findings) { table(:vulnerability_occurrences) }
  let(:remediations) { table(:vulnerability_remediations) }

  let(:namespace) { namespaces.create!(name: 'gitlab', path: 'gitlab-org') }
  let(:project_1) { projects.create!(namespace_id: namespace.id, name: 'foo') }
  let(:project_2) { projects.create!(namespace_id: namespace.id, name: 'bar') }
  let(:scanner_1) { scanners.create!(project_id: project_1.id, external_id: 'foo', name: 'bar') }
  let(:scanner_2) { scanners.create!(project_id: project_2.id, external_id: 'foo', name: 'bar') }
  let(:identifier_1) { identifiers.create!(project_id: project_1.id, fingerprint: 'foo', external_type: 'bar', external_id: 'zoo', name: 'baz') }
  let(:identifier_2) { identifiers.create!(project_id: project_2.id, fingerprint: 'foo', external_type: 'bar', external_id: 'zoo', name: 'baz') }
  let(:existing_diff) { 'existing diff' }
  let(:existing_checksum) { [Digest::SHA256.hexdigest(existing_diff)].pack('H*') }
  let(:long_summary_text) { 'a' * 300 }
  let(:empty_metadata) { '{}' }
  let(:broken_metadata) { '{' }
  let(:primitive_metadata) { '""' }
  let(:empty_remediations) { { remediations: [] }.to_json }
  let(:null_remediation) { { remediations: [nil] }.to_json }
  let(:remediation_without_diff) { { remediations: [{ summary: 'foo' }] }.to_json }
  let(:remediation_without_summary) { { remediations: [{ diff: '...' }] }.to_json }
  let(:existing_remediation_data) { { remediations: [{ summary: 'Foo', diff: existing_diff }] }.to_json }
  let(:remediation_1) { { remediations: [{ summary: 'Foo', diff: 'Zoo' }] }.to_json }
  let(:remediation_2) { { remediations: [{ summary: long_summary_text, diff: 'Taz' }] }.to_json }
  let(:remediation_3) { { remediations: [{ summary: 'Foo', diff: 'Zoo' }, { summary: 'Baz', diff: 'Taz' }] }.to_json }
  let(:finding_creator) do
    -> (project, identifier, scanner, raw_metadata) do
      findings.create!(
        project_id: project.id,
        primary_identifier_id: identifier.id,
        scanner_id: scanner.id,
        raw_metadata: raw_metadata,
        uuid: SecureRandom.uuid,
        location_fingerprint: Digest::SHA256.hexdigest(SecureRandom.uuid),
        name: 'Foo',
        project_fingerprint: 'bar',
        metadata_version: '1',
        severity: 0,
        confidence: 5,
        report_type: 2
      )
    end
  end

  subject(:populate_vulnerability_remediations) { described_class.new.perform(project_1, project_2) }

  before do
    finding_creator.call(project_1, identifier_1, scanner_1, empty_metadata)
    finding_creator.call(project_1, identifier_1, scanner_1, broken_metadata)
    finding_creator.call(project_1, identifier_1, scanner_1, primitive_metadata)
    finding_creator.call(project_1, identifier_1, scanner_1, empty_remediations)
    finding_creator.call(project_1, identifier_1, scanner_1, null_remediation)
    finding_creator.call(project_1, identifier_1, scanner_1, remediation_without_diff)
    finding_creator.call(project_1, identifier_1, scanner_1, remediation_without_summary)
    finding_creator.call(project_1, identifier_1, scanner_1, remediation_1)
    finding_creator.call(project_1, identifier_1, scanner_1, remediation_2)
    finding_creator.call(project_1, identifier_1, scanner_1, remediation_3)
    finding_creator.call(project_2, identifier_2, scanner_2, remediation_3)
    finding_creator.call(project_2, identifier_2, scanner_2, existing_remediation_data)

    remediations.create!(project_id: project_2.id, summary: 'Foo', checksum: existing_checksum, file: 'file_path')

    project_settings.create!(project_id: project_1.id, has_vulnerabilities: true)
    project_settings.create!(project_id: project_2.id, has_vulnerabilities: true)

    allow(Gitlab::BackgroundMigration::Logger).to receive_messages(info: true, warn: true)
  end

  describe '#perform' do
    it 'creates remediation entries in the database' do
      expect { populate_vulnerability_remediations }.to change { remediations.count }.from(1).to(5)

      expect(Gitlab::BackgroundMigration::Logger).to have_received(:warn).once
      expect(Gitlab::BackgroundMigration::Logger).to have_received(:info).once
    end
  end
end
